// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Glob = require("glob");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Rimraf = require("rimraf");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Mustache = require("mustache");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var FrontMatter = require("front-matter");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Format = require("date-fns/format");
var Markdown$ReasonBlog = require("./bindings/Markdown.bs.js");

var NodeError = Caml_exceptions.create("Index-ReasonBlog.NodeError");

var blogTitle = "ReasonML Notes";

var postsDir = "./content/posts";

var templatesDir = "./content/templates";

var docsDir = "./docs";

function readFile(path) {
  return new Promise((function (resolve, reject) {
                var onRead = function (error, data) {
                  if (error == null) {
                    if (data == null) {
                      return reject({
                                  RE_EXN_ID: NodeError,
                                  _1: "Reading post file returned null"
                                });
                    } else {
                      return resolve(data);
                    }
                  } else {
                    return reject({
                                RE_EXN_ID: NodeError,
                                _1: "Error reading post file"
                              });
                  }
                };
                Fs.readFile(path, "utf-8", onRead);
                
              }));
}

function createDocsDir(param) {
  if (!Fs.existsSync(docsDir)) {
    Fs.mkdirSync(docsDir);
    return ;
  }
  
}

function cleanDocsDir(param) {
  return new Promise((function (resolve, reject) {
                return Rimraf(docsDir, (function (error) {
                              if (error == null) {
                                createDocsDir(undefined);
                                return resolve(function (prim) {
                                            
                                          });
                              } else {
                                return reject({
                                            RE_EXN_ID: NodeError,
                                            _1: "Error deleting the docs directory"
                                          });
                              }
                            }));
              }));
}

function pathToKey(path) {
  return Path.basename(path, ".md");
}

function formatDate(date) {
  return Format(date, "yyyy-MM-dd");
}

function writePost(key, html) {
  return new Promise((function (resolve, reject) {
                var fileName = "./docs/" + key + ".html";
                Fs.writeFile(fileName, html, (function (error) {
                        if (error == null) {
                          return resolve(key);
                        } else {
                          return reject({
                                      RE_EXN_ID: NodeError,
                                      _1: "Error writing post file"
                                    });
                        }
                      }));
                
              }));
}

function applyTemplate(template, post) {
  var partial_arg = {
    title: post.title,
    body: post.body
  };
  return function (param, param$1) {
    return Mustache.render(template, partial_arg, param !== undefined ? Caml_option.valFromOption(param) : undefined);
  };
}

function writePosts(posts) {
  var postTemplatePath = "./content/templates/post.html";
  return readFile(postTemplatePath).then(function (template) {
              return Promise.all($$Array.map((function (post) {
                                  var data = {
                                    blogTitle: blogTitle,
                                    date: Format(post.date, "yyyy-MM-dd"),
                                    title: post.title,
                                    body: post.body
                                  };
                                  var html = Mustache.render(template, data, undefined);
                                  return writePost(post.key, html);
                                }), posts)).then(function (param) {
                          return Promise.resolve(undefined);
                        });
            });
}

function getValue(attributes, key) {
  var value = Js_dict.get(attributes, key);
  if (value !== undefined) {
    return value;
  } else {
    return "";
  }
}

function readPost(path) {
  return readFile(path).then(function (data) {
              var key = Path.basename(path, ".md");
              var fmData = FrontMatter(data);
              var attributes = fmData.attributes;
              var body = Markdown$ReasonBlog.markdownIt.render(fmData.body);
              var match = attributes.title;
              var match$1 = attributes.date;
              if (match !== undefined) {
                if (match$1 !== undefined) {
                  return Promise.resolve({
                              key: key,
                              date: Caml_option.valFromOption(match$1),
                              title: match,
                              body: body
                            });
                } else {
                  return Promise.reject({
                              RE_EXN_ID: "Failure",
                              _1: "Invalid post attributes: " + path
                            });
                }
              } else {
                return Promise.reject({
                            RE_EXN_ID: "Failure",
                            _1: "Invalid post attributes: " + path
                          });
              }
            });
}

function sortByDateDescending(postA, postB) {
  var a = postA.date;
  var b = postB.date;
  if (Caml_obj.caml_equal(a, b)) {
    return 0;
  } else if (Caml_obj.caml_lessthan(a, b)) {
    return 1;
  } else {
    return -1;
  }
}

function sortPosts(posts) {
  $$Array.stable_sort(sortByDateDescending, posts);
  return posts;
}

function readPosts(paths) {
  return Promise.all($$Array.map(readPost, paths)).then(function (posts) {
              return Promise.resolve(($$Array.stable_sort(sortByDateDescending, posts), posts));
            });
}

function readPostPaths(param) {
  return new Promise((function (resolve, reject) {
                Glob("./content/posts/*.md", (function (error, paths) {
                        if (error == null) {
                          return resolve(paths);
                        } else {
                          return reject({
                                      RE_EXN_ID: NodeError,
                                      _1: "Error reading post paths"
                                    });
                        }
                      }));
                
              }));
}

function writeIndexFile(html) {
  return new Promise((function (resolve, reject) {
                var fileName = "./docs/index.html";
                Fs.writeFile(fileName, html, (function (error) {
                        if (error == null) {
                          return resolve(function (prim) {
                                      
                                    });
                        } else {
                          return reject({
                                      RE_EXN_ID: NodeError,
                                      _1: "Error writing index file"
                                    });
                        }
                      }));
                
              }));
}

function writeIndex(posts) {
  var indexTemplatePath = "./content/templates/index.html";
  return readFile(indexTemplatePath).then(function (template) {
                var postsData = $$Array.map((function (post) {
                        return {
                                path: post.key + ".html",
                                date: Format(post.date, "yyyy-MM-dd"),
                                title: post.title
                              };
                      }), posts);
                return writeIndexFile(Mustache.render(template, {
                                blogTitle: blogTitle,
                                posts: postsData
                              }, undefined));
              }).then(function (param) {
              return Promise.resolve(undefined);
            });
}

readPostPaths(undefined).then(readPosts).then(function (posts) {
        return cleanDocsDir(undefined).then(function (param) {
                    return Promise.all([
                                writeIndex(posts),
                                writePosts(posts)
                              ]);
                  });
      }).catch(function (error) {
      console.log(error);
      return Promise.resolve([]);
    });

exports.NodeError = NodeError;
exports.blogTitle = blogTitle;
exports.postsDir = postsDir;
exports.templatesDir = templatesDir;
exports.docsDir = docsDir;
exports.readFile = readFile;
exports.createDocsDir = createDocsDir;
exports.cleanDocsDir = cleanDocsDir;
exports.pathToKey = pathToKey;
exports.formatDate = formatDate;
exports.writePost = writePost;
exports.applyTemplate = applyTemplate;
exports.writePosts = writePosts;
exports.getValue = getValue;
exports.readPost = readPost;
exports.sortByDateDescending = sortByDateDescending;
exports.sortPosts = sortPosts;
exports.readPosts = readPosts;
exports.readPostPaths = readPostPaths;
exports.writeIndexFile = writeIndexFile;
exports.writeIndex = writeIndex;
/*  Not a pure module */
